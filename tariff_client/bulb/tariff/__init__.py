# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tariff.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class FuelType(betterproto.Enum):
    UNKNOWN_FUEL = 0
    ELECTRICITY = 1
    GAS = 2


class TariffType(betterproto.Enum):
    UNKNOWN_TARIFF = 0
    VARIABLE = 1
    FIXED = 2


class PublicationStatus(betterproto.Enum):
    UNKNOWN_STATUS = 0
    UNDER_CONSTRUCTION = 1
    DRAFT = 2
    LIVE = 3
    ARCHIVED = 4


class PaymentMethod(betterproto.Enum):
    UNKNOWN_PAYMENT_METHOD = 0
    DIRECT_DEBIT = 1


class Interval(betterproto.Enum):
    UNKNOWN_INTERVAL = 0
    NEVER = 1
    DAILY = 2


class Unit(betterproto.Enum):
    UNKNOWN_UNIT = 0
    KWH = 1


@dataclass(eq=False, repr=False)
class Ids(betterproto.Message):
    ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class References(betterproto.Message):
    references: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class ListTariffsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListTariffsResponse(betterproto.Message):
    tariffs: List["Tariff"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BatchGetTariffsRequest(betterproto.Message):
    ids: List[str] = betterproto.string_field(1)
    references: List[str] = betterproto.string_field(2)
    fuel_types: List[str] = betterproto.string_field(3)
    tariff_types: List[str] = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class BatchGetTariffsResponse(betterproto.Message):
    tariffs: List["Tariff"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GetTariffRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class UpdateTariffRequest(betterproto.Message):
    tariff: "Tariff" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Tariff(betterproto.Message):
    # the unique short code for the tariff (cannot be changed) TODO work out how
    # this interacts with multiple Junifer tariffs -> one Iris tariff
    id: str = betterproto.string_field(1)
    # the human-readable name for the tariff (can change)
    name: str = betterproto.string_field(2)
    # which fuel types this tariff is applicable to (it will have prices for
    # every fuel listed here)
    fuel_types: List["FuelType"] = betterproto.enum_field(3)
    # what payment method this tariff is for (a filter on where this tariff is
    # used)
    payment_method: "PaymentMethod" = betterproto.enum_field(4)
    # whether the tariff is variable or fixed
    tariff_type: "TariffType" = betterproto.enum_field(5)
    # whether the tariff is under construction, or in draft, or live
    publication_status: "PublicationStatus" = betterproto.enum_field(6)
    # when the tariff begins being available to members
    available_from: datetime = betterproto.message_field(7)
    # (optional) when the tariff ceases being available to members
    available_to: Optional[datetime] = betterproto.message_field(
        8, optional=True, group="_available_to"
    )
    # a description of features enabled for the tariff
    features: "TariffFeatures" = betterproto.message_field(9)
    blah: int = betterproto.int64_field(10)


@dataclass(eq=False, repr=False)
class TariffFeatures(betterproto.Message):
    # all the times of day when rates start there are as many rates as there are
    # entries in this list e.g. ['02:00', '06:00'] for an EV tariff
    rate_start_times: List[str] = betterproto.string_field(1)
    # the regularity at which the member is charged the standing charge
    standing_charge_interval: "Interval" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class TariffRegion(betterproto.Message):
    """The pricing of a Tariff in a particular region."""

    # in UK this is a GSP group
    region_name: str = betterproto.string_field(1)
    # the map of FuelTypes to lists of PricePacks (can't use map<...> because of
    # enum and repeated)
    price_packs_for_fuel: "PricePacksForFuel" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PricePacksForFuel(betterproto.Message):
    # which fuel type the PricePacks are for
    fuel_type: "FuelType" = betterproto.enum_field(1)
    # all the prices for a region and fuel (PricePacks contain when they apply
    # from)
    price_packs: List["PricePack"] = betterproto.message_field(2)
    # Which Junifer tariffs are encompassed by this tariff-region-fuel?? TODO
    # sanity check
    legacy_references: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PricePack(betterproto.Message):
    """
    Prices for a single region and fuel type, starting from a date. A PricePack
    is flexible and requires validation to 'fit' in a tariff.
    """

    # when these prices starts affecting existing members
    existing_members_effective_at: datetime = betterproto.message_field(1)
    # when these prices starts affecting new members
    new_members_effective_at: datetime = betterproto.message_field(2)
    # the price of energy for each time interval described in TariffFeatures in
    # order, e.g. if the rate_start_times are ['02:00', '06:00'] - there are
    # exactly two unit_rates - the first unit_rates item is the price for
    # 02:00-06:00 - the second unit_rates item is the price for 06:00-02:00
    unit_rates: List["UnitRate"] = betterproto.message_field(3)
    # the standing charge that applies to every meter this tariff covers (if we
    # discover we want multiple StandingCharges we can change this to 'repeated'
    # without breaking wire compatibility but old clients would only 'see' the
    # last one in the list)
    standing_charges: Optional["StandingCharge"] = betterproto.message_field(
        4, optional=True, group="_standing_charges"
    )


@dataclass(eq=False, repr=False)
class UnitRate(betterproto.Message):
    # cents per unit (e.g. pence per kWh)
    cents: float = betterproto.double_field(1)
    # unit of energy
    unit: "Unit" = betterproto.enum_field(2)
    # empty for single rate, otherwise when in the day the rate starts applying
    # e.g. '02:00'
    start_time: Optional[str] = betterproto.string_field(
        3, optional=True, group="_start_time"
    )
    # empty for single rate, otherwise when in the day the rate stops applying
    # (this can be 'before' start_time, in which case it wraps around midnight)
    # e.g. '06:00'
    end_time: Optional[str] = betterproto.string_field(
        4, optional=True, group="_end_time"
    )


@dataclass(eq=False, repr=False)
class StandingCharge(betterproto.Message):
    # cents per interval
    cents: float = betterproto.double_field(1)
    # the regularity at which the member is charged the standing charge
    interval: "Interval" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class PriceChange(betterproto.Message):
    # when the price change was created
    created_at: datetime = betterproto.message_field(1)
    # when the price changes (if published) starts affecting existing members
    existing_members_effective_at: datetime = betterproto.message_field(2)
    # when the price changes (if published) starts affecting new members
    new_members_effective_at: datetime = betterproto.message_field(3)
    # when the price change was published (if it hasn't got a published_at, it's
    # in draft)
    published_at: Optional[datetime] = betterproto.message_field(
        4, optional=True, group="_published_at"
    )
    # TODO something something actions/approval how much progress has been made
    # with applying the published price change
    orchestration_steps: "OrchestrationSteps" = betterproto.message_field(5)
    # all the actual new pricing information TODO try to name this better
    price_changes_by_tariff_region: List[
        "PriceChangeTariffRegion"
    ] = betterproto.message_field(6)


@dataclass(eq=False, repr=False)
class OrchestrationSteps(betterproto.Message):
    """TODO decide if we even want to have anything for this yet"""

    junifer_updated: bool = betterproto.bool_field(1)
    pcws_updated: bool = betterproto.bool_field(2)
    comms_sent: bool = betterproto.bool_field(3)
    pay_review_completed: bool = betterproto.bool_field(4)


@dataclass(eq=False, repr=False)
class PriceChangeTariffRegion(betterproto.Message):
    """TODO decide if this should have more hierarchy"""

    # the unique short code of a tariff
    tariff_id: str = betterproto.string_field(1)
    # in UK this is a GSP group
    region_name: str = betterproto.string_field(2)
    # the map of FuelTypes to new PricePacks
    price_packs_for_fuel: List["PricePacksForFuel"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class PricePackForFuel(betterproto.Message):
    # which fuel type the PricePack is for
    fuel_type: "FuelType" = betterproto.enum_field(1)
    # the new price for the region and fuel
    price_packs: List["PricePack"] = betterproto.message_field(2)


class TariffServiceStub(betterproto.ServiceStub):
    async def list_tariffs(self) -> "ListTariffsResponse":

        request = ListTariffsRequest()

        return await self._unary_unary(
            "/bulb.tariff.TariffService/ListTariffs", request, ListTariffsResponse
        )

    async def batch_get_tariffs(
        self,
        *,
        ids: Optional[List[str]] = None,
        references: Optional[List[str]] = None,
        fuel_types: Optional[List[str]] = None,
        tariff_types: Optional[List[str]] = None
    ) -> "BatchGetTariffsResponse":
        ids = ids or []
        references = references or []
        fuel_types = fuel_types or []
        tariff_types = tariff_types or []

        request = BatchGetTariffsRequest()
        request.ids = ids
        request.references = references
        request.fuel_types = fuel_types
        request.tariff_types = tariff_types

        return await self._unary_unary(
            "/bulb.tariff.TariffService/BatchGetTariffs",
            request,
            BatchGetTariffsResponse,
        )

    async def get_tariff(self, *, id: str = "") -> "Tariff":

        request = GetTariffRequest()
        request.id = id

        return await self._unary_unary(
            "/bulb.tariff.TariffService/GetTariff", request, Tariff
        )

    async def update_tariff(self, *, tariff: "Tariff" = None) -> "Tariff":

        request = UpdateTariffRequest()
        if tariff is not None:
            request.tariff = tariff

        return await self._unary_unary(
            "/bulb.tariff.TariffService/UpdateTariff", request, Tariff
        )


class TariffServiceBase(ServiceBase):
    async def list_tariffs(self) -> "ListTariffsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_get_tariffs(
        self,
        ids: Optional[List[str]],
        references: Optional[List[str]],
        fuel_types: Optional[List[str]],
        tariff_types: Optional[List[str]],
    ) -> "BatchGetTariffsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_tariff(self, id: str) -> "Tariff":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_tariff(self, tariff: "Tariff") -> "Tariff":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_tariffs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.list_tariffs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_batch_get_tariffs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "ids": request.ids,
            "references": request.references,
            "fuel_types": request.fuel_types,
            "tariff_types": request.tariff_types,
        }

        response = await self.batch_get_tariffs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_tariff(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
        }

        response = await self.get_tariff(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_tariff(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tariff": request.tariff,
        }

        response = await self.update_tariff(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/bulb.tariff.TariffService/ListTariffs": grpclib.const.Handler(
                self.__rpc_list_tariffs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListTariffsRequest,
                ListTariffsResponse,
            ),
            "/bulb.tariff.TariffService/BatchGetTariffs": grpclib.const.Handler(
                self.__rpc_batch_get_tariffs,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchGetTariffsRequest,
                BatchGetTariffsResponse,
            ),
            "/bulb.tariff.TariffService/GetTariff": grpclib.const.Handler(
                self.__rpc_get_tariff,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetTariffRequest,
                Tariff,
            ),
            "/bulb.tariff.TariffService/UpdateTariff": grpclib.const.Handler(
                self.__rpc_update_tariff,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateTariffRequest,
                Tariff,
            ),
        }
