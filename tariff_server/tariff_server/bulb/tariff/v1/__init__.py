# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tariff.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class FuelType(betterproto.Enum):
    UNKNOWN_FUEL = 0
    ELECTRICITY = 1
    GAS = 2


class TariffType(betterproto.Enum):
    UNKNOWN_TARIFF = 0
    VARIABLE = 1
    FIXED = 2


class PublicationStatus(betterproto.Enum):
    UNKNOWN_STATUS = 0
    UNDER_CONSTRUCTION = 1
    DRAFT = 2
    LIVE = 3
    ARCHIVED = 4


class PaymentMethod(betterproto.Enum):
    UNKNOWN_PAYMENT_METHOD = 0
    DIRECT_DEBIT = 1


class Interval(betterproto.Enum):
    UNKNOWN_INTERVAL = 0
    NEVER = 1
    DAILY = 2


class Unit(betterproto.Enum):
    UNKNOWN_UNIT = 0
    KWH = 1


@dataclass(eq=False, repr=False)
class ListTariffsRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ListTariffsResponse(betterproto.Message):
    tariffs: List["Tariff"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BatchGetTariffsRequest(betterproto.Message):
    tariff_ids: List[str] = betterproto.string_field(1)
    fuel_types: List[str] = betterproto.string_field(3)
    tariff_types: List["TariffType"] = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class BatchGetTariffsResponse(betterproto.Message):
    tariffs: List["Tariff"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GetTariffRequest(betterproto.Message):
    tariff_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class UpdateTariffRequest(betterproto.Message):
    tariff: "Tariff" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GetRatesForTariffRequest(betterproto.Message):
    tariff_id: str = betterproto.string_field(1)
    fuel_types: List["FuelType"] = betterproto.enum_field(2)
    region_codes: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PriceChangeTariffPricePack(betterproto.Message):
    price_change_id: str = betterproto.string_field(1)
    tariff_id: str = betterproto.string_field(2)
    price_pack: "PricePack" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Tariff(betterproto.Message):
    # the UUID of the tariff
    tariff_id: str = betterproto.string_field(1)
    # the human-readable name for the tariff (can change)
    name: str = betterproto.string_field(2)
    # which fuel types this tariff is applicable to (it will have prices for
    # every fuel listed here)
    fuel_types: List["FuelType"] = betterproto.enum_field(3)
    # what payment method this tariff is for (a filter on where this tariff is
    # used)
    payment_method: "PaymentMethod" = betterproto.enum_field(4)
    # whether the tariff is variable or fixed
    tariff_type: "TariffType" = betterproto.enum_field(5)
    # whether the tariff is under construction, or in draft, or live
    publication_status: "PublicationStatus" = betterproto.enum_field(6)
    # when the tariff begins being available to members
    available_from: datetime = betterproto.message_field(7)
    # (optional) when the tariff ceases being available to members
    available_to: Optional[datetime] = betterproto.message_field(
        8, optional=True, group="_available_to"
    )
    # a description of features enabled for the tariff
    features: "TariffFeatures" = betterproto.message_field(9)


@dataclass(eq=False, repr=False)
class TariffFeatures(betterproto.Message):
    # all the times of day when rates start there are as many rates as there are
    # entries in this list e.g. ['02:00', '06:00'] for an EV tariff
    rate_start_times: List[str] = betterproto.string_field(1)
    # the regularity at which the member is charged the standing charge
    standing_charge_interval: "Interval" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class PricePack(betterproto.Message):
    """
    Prices for a single region and fuel type, starting from a date. A PricePack
    is flexible and requires validation to 'fit' in a tariff.
    """

    # in UK this is a GSP group
    region_code: str = betterproto.string_field(1)
    # which fuel type these are prices for
    fuel_type: "FuelType" = betterproto.enum_field(2)
    # when these prices starts affecting existing members
    existing_members_effective_at: datetime = betterproto.message_field(3)
    # when these prices starts affecting new members
    new_members_effective_at: datetime = betterproto.message_field(4)
    # the price of energy for each time interval described in TariffFeatures in
    # order, e.g. if the rate_start_times are ['02:00', '06:00'] - there are
    # exactly two unit_rates - the first unit_rates item is the price for
    # 02:00-06:00 - the second unit_rates item is the price for 06:00-02:00
    unit_rates: List["UnitRate"] = betterproto.message_field(5)
    # the standing charge that applies to every meter this tariff covers (if we
    # discover we want multiple StandingCharges we can change this to 'repeated'
    # without breaking wire compatibility but old clients would only 'see' the
    # last one in the list)
    standing_charge: Optional["StandingCharge"] = betterproto.message_field(
        6, optional=True, group="_standing_charge"
    )


@dataclass(eq=False, repr=False)
class UnitRate(betterproto.Message):
    # cents per unit (e.g. pence per kWh)
    cents: float = betterproto.double_field(1)
    # unit of energy
    unit: "Unit" = betterproto.enum_field(2)
    # empty for single rate, otherwise when in the day the rate starts applying
    # e.g. '02:00'
    start_time: Optional[str] = betterproto.string_field(
        3, optional=True, group="_start_time"
    )


@dataclass(eq=False, repr=False)
class StandingCharge(betterproto.Message):
    # cents per interval
    cents: float = betterproto.double_field(1)
    # the regularity at which the member is charged the standing charge
    interval: "Interval" = betterproto.enum_field(2)


@dataclass(eq=False, repr=False)
class PriceChange(betterproto.Message):
    # the UUID of the price change
    price_change_id: str = betterproto.string_field(1)
    # when the price change was created
    created_at: datetime = betterproto.message_field(2)
    # when the price changes (if published) starts affecting existing members
    existing_members_effective_at: datetime = betterproto.message_field(3)
    # when the price changes (if published) starts affecting new members
    new_members_effective_at: datetime = betterproto.message_field(4)
    # when the price change was published (if it hasn't got a published_at, it's
    # in draft)
    published_at: Optional[datetime] = betterproto.message_field(
        5, optional=True, group="_published_at"
    )
    # what reviews have been requested and their status
    reviews: List["Review"] = betterproto.message_field(6)
    # how much progress has been made with applying the published price change
    orchestration_steps: "OrchestrationSteps" = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class Review(betterproto.Message):
    reviewer: str = betterproto.string_field(1)
    approved: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class OrchestrationSteps(betterproto.Message):
    junifer_updated: bool = betterproto.bool_field(1)
    pcws_updated: bool = betterproto.bool_field(2)
    comms_sent: bool = betterproto.bool_field(3)
    pay_review_completed: bool = betterproto.bool_field(4)


class TariffServiceStub(betterproto.ServiceStub):
    async def list_tariffs(self) -> "ListTariffsResponse":

        request = ListTariffsRequest()

        return await self._unary_unary(
            "/bulb.tariff.v1.TariffService/ListTariffs", request, ListTariffsResponse
        )

    async def batch_get_tariffs(
        self,
        *,
        tariff_ids: Optional[List[str]] = None,
        fuel_types: Optional[List[str]] = None,
        tariff_types: Optional[List["TariffType"]] = None
    ) -> "BatchGetTariffsResponse":
        tariff_ids = tariff_ids or []
        fuel_types = fuel_types or []
        tariff_types = tariff_types or []

        request = BatchGetTariffsRequest()
        request.tariff_ids = tariff_ids
        request.fuel_types = fuel_types
        request.tariff_types = tariff_types

        return await self._unary_unary(
            "/bulb.tariff.v1.TariffService/BatchGetTariffs",
            request,
            BatchGetTariffsResponse,
        )

    async def get_tariff(self, *, tariff_id: str = "") -> "Tariff":

        request = GetTariffRequest()
        request.tariff_id = tariff_id

        return await self._unary_unary(
            "/bulb.tariff.v1.TariffService/GetTariff", request, Tariff
        )

    async def update_tariff(self, *, tariff: "Tariff" = None) -> "Tariff":

        request = UpdateTariffRequest()
        if tariff is not None:
            request.tariff = tariff

        return await self._unary_unary(
            "/bulb.tariff.v1.TariffService/UpdateTariff", request, Tariff
        )

    async def stream_rates_for_tariff(
        self,
        *,
        tariff_id: str = "",
        fuel_types: Optional[List["FuelType"]] = None,
        region_codes: Optional[List[str]] = None
    ) -> AsyncIterator["PricePack"]:
        fuel_types = fuel_types or []
        region_codes = region_codes or []

        request = GetRatesForTariffRequest()
        request.tariff_id = tariff_id
        request.fuel_types = fuel_types
        request.region_codes = region_codes

        async for response in self._unary_stream(
            "/bulb.tariff.v1.TariffService/StreamRatesForTariff",
            request,
            PricePack,
        ):
            yield response

    async def stream_update_rates_for_price_change(
        self,
        request_iterator: Union[
            AsyncIterable["PriceChangeTariffPricePack"],
            Iterable["PriceChangeTariffPricePack"],
        ],
    ) -> "betterproto_lib_google_protobuf.Empty":

        return await self._stream_unary(
            "/bulb.tariff.v1.TariffService/StreamUpdateRatesForPriceChange",
            request_iterator,
            PriceChangeTariffPricePack,
            betterproto_lib_google_protobuf.Empty,
        )


class TariffServiceBase(ServiceBase):
    async def list_tariffs(self) -> "ListTariffsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def batch_get_tariffs(
        self,
        tariff_ids: Optional[List[str]],
        fuel_types: Optional[List[str]],
        tariff_types: Optional[List["TariffType"]],
    ) -> "BatchGetTariffsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_tariff(self, tariff_id: str) -> "Tariff":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_tariff(self, tariff: "Tariff") -> "Tariff":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_rates_for_tariff(
        self,
        tariff_id: str,
        fuel_types: Optional[List["FuelType"]],
        region_codes: Optional[List[str]],
    ) -> AsyncIterator["PricePack"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def stream_update_rates_for_price_change(
        self, request_iterator: AsyncIterator["PriceChangeTariffPricePack"]
    ) -> "betterproto_lib_google_protobuf.Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_tariffs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.list_tariffs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_batch_get_tariffs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tariff_ids": request.tariff_ids,
            "fuel_types": request.fuel_types,
            "tariff_types": request.tariff_types,
        }

        response = await self.batch_get_tariffs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_tariff(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tariff_id": request.tariff_id,
        }

        response = await self.get_tariff(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_tariff(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tariff": request.tariff,
        }

        response = await self.update_tariff(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_stream_rates_for_tariff(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tariff_id": request.tariff_id,
            "fuel_types": request.fuel_types,
            "region_codes": request.region_codes,
        }

        await self._call_rpc_handler_server_stream(
            self.stream_rates_for_tariff,
            stream,
            request_kwargs,
        )

    async def __rpc_stream_update_rates_for_price_change(
        self, stream: grpclib.server.Stream
    ) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        response = await self.stream_update_rates_for_price_change(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/bulb.tariff.v1.TariffService/ListTariffs": grpclib.const.Handler(
                self.__rpc_list_tariffs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListTariffsRequest,
                ListTariffsResponse,
            ),
            "/bulb.tariff.v1.TariffService/BatchGetTariffs": grpclib.const.Handler(
                self.__rpc_batch_get_tariffs,
                grpclib.const.Cardinality.UNARY_UNARY,
                BatchGetTariffsRequest,
                BatchGetTariffsResponse,
            ),
            "/bulb.tariff.v1.TariffService/GetTariff": grpclib.const.Handler(
                self.__rpc_get_tariff,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetTariffRequest,
                Tariff,
            ),
            "/bulb.tariff.v1.TariffService/UpdateTariff": grpclib.const.Handler(
                self.__rpc_update_tariff,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateTariffRequest,
                Tariff,
            ),
            "/bulb.tariff.v1.TariffService/StreamRatesForTariff": grpclib.const.Handler(
                self.__rpc_stream_rates_for_tariff,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetRatesForTariffRequest,
                PricePack,
            ),
            "/bulb.tariff.v1.TariffService/StreamUpdateRatesForPriceChange": grpclib.const.Handler(
                self.__rpc_stream_update_rates_for_price_change,
                grpclib.const.Cardinality.STREAM_UNARY,
                PriceChangeTariffPricePack,
                betterproto_lib_google_protobuf.Empty,
            ),
        }


import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
