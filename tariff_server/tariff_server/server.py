import asyncio
import uuid
from datetime import datetime
from typing import Optional, AsyncIterator

import grpclib
from betterproto.lib.google import protobuf
from betterproto.lib.google.protobuf import FieldMask
from dateutil.tz import UTC
from grpclib._typing import IServable
from grpclib.health.check import ServiceCheck
from grpclib.health.service import Health, OVERALL
from grpclib.reflection.service import ServerReflection
from grpclib.server import Server
from grpclib.utils import graceful_exit

from .metadata import listen_for_metadata
from .bulb.tariff.v1 import (
    TariffServiceBase,
    Tariff,
    ListTariffsResponse,
    PaymentMethod,
    TariffType,
    PublicationStatus,
    TariffFeatures,
    Interval,
    BatchGetTariffsResponse,
    FuelType,
    PricePack,
    UnitRate,
    Unit,
    StandingCharge,
    PriceChangeTariffPricePack,
)


# Need to import tariff_pb2 (as generated by protoc --python_out) to populate
# the protobuf SymbolDatabase, which is used by
# grpclib.reflection.service.ServerReflection.
# (If we didn't want to provide reflection, we wouldn't need this file at all.)
from .tariff_pb2 import _sym_db

TARIFF_ID_1 = str(uuid.uuid4())
TARIFF_ID_2 = str(uuid.uuid4())

TARIFFS: dict[str, Tariff] = {
    TARIFF_ID_1: Tariff(
        tariff_id=TARIFF_ID_1,
        name="EV Tariff",
        fuel_types=[FuelType.ELECTRICITY],
        payment_method=PaymentMethod.DIRECT_DEBIT,
        tariff_type=TariffType.VARIABLE,
        publication_status=PublicationStatus.DRAFT,
        available_from=datetime(2022, 6, 1, tzinfo=UTC),
        available_to=datetime(2023, 6, 1, tzinfo=UTC),
        features=TariffFeatures(
            rate_start_times=["02:00", "06:00"],
            standing_charge_interval=Interval.DAILY,
        ),
        legacy_reference="EV2R-V01-201216",
    ),
    TARIFF_ID_2: Tariff(
        tariff_id=TARIFF_ID_2,
        name="Pay Monthly Variable",
        fuel_types=[FuelType.ELECTRICITY, FuelType.GAS],
        payment_method=PaymentMethod.DIRECT_DEBIT,
        tariff_type=TariffType.VARIABLE,
        publication_status=PublicationStatus.LIVE,
        available_from=datetime(2022, 2, 1, tzinfo=UTC),
        features=TariffFeatures(
            # rate_start_times=[],
            standing_charge_interval=Interval.DAILY,
        ),
    ),
}

PRICE_CHANGE_DATETIMES = [
    datetime(2020, 1, 1, tzinfo=UTC),
    datetime(2021, 1, 1, tzinfo=UTC),
    datetime(2022, 1, 1, tzinfo=UTC),
]


class TariffService(TariffServiceBase):
    async def list_tariffs(self) -> ListTariffsResponse:
        return ListTariffsResponse(tariffs=list(TARIFFS.values()))

    async def batch_get_tariffs(
        self,
        tariff_ids: list[str] | None,
        fuel_types: list[FuelType] | None,
        tariff_types: list[TariffType] | None,
    ) -> BatchGetTariffsResponse:
        if tariff_ids:
            if fuel_types or tariff_types:
                raise grpclib.GRPCError(
                    status=grpclib.const.Status.INVALID_ARGUMENT,
                    message="requesting ids is not compatible with filtering by fuel_types or tariff_types",
                )
            return BatchGetTariffsResponse(
                [TARIFFS[tariff_id] for tariff_id in tariff_ids]
            )
        if fuel_types or tariff_types:
            return BatchGetTariffsResponse(
                [
                    tariff
                    for tariff in TARIFFS.values()
                    if (not fuel_types or (set(tariff.fuel_types) & set(fuel_types)))
                    and (not tariff_types or tariff.tariff_type in tariff_types)
                ]
            )
        else:
            raise grpclib.GRPCError(
                status=grpclib.const.Status.INVALID_ARGUMENT,
                message="one of ids, fuel_types or tariff_types must be provided",
            )

    async def get_tariff(self, tariff_id: str) -> Tariff:
        try:
            return TARIFFS[tariff_id]
        except Exception:
            raise grpclib.GRPCError(
                message=f"cannot find {tariff_id}",
                status=grpclib.const.Status.NOT_FOUND,
            )

    async def update_tariff(
        self,
        tariff: Tariff,
        update_mask: FieldMask,
    ) -> Tariff:
        # TODO: investigate using FieldMask for update methods
        #  betterproto doesn't have a "MergeMessage" implementation at present to make FieldMask useful
        # the base google.protobuf FieldMask implementation:
        # from google.protobuf.field_mask_pb2 import FieldMask
        if tariff.tariff_id not in TARIFFS:
            raise grpclib.GRPCError(
                message=f"Cannot find {id}", status=grpclib.const.Status.NOT_FOUND
            )

        if update_mask.paths:
            raise grpclib.GRPCError(
                message="betterproto makes FieldMasks harder", status=grpclib.const.Status.UNIMPLEMENTED,
            )

        TARIFFS[tariff.tariff_id] = tariff
        return tariff

    # unfortunately mypy doesn't handle the superclass not using yield when
    # actual definitions do: https://github.com/python/mypy/issues/10732
    async def stream_rates_for_tariff(  # type: ignore
        self,
        tariff_id: str,
        fuel_types: Optional[list[FuelType]],
        region_codes: Optional[list[str]],
    ) -> AsyncIterator[PricePack]:
        if not fuel_types or not region_codes:
            raise grpclib.GRPCError(
                status=grpclib.const.Status.INVALID_ARGUMENT,
                message="fuel_types and region_codes are required",
            )

        try:
            tariff = TARIFFS[tariff_id]
        except KeyError:
            raise grpclib.GRPCError(
                message=f"Cannot find tariff {tariff_id}",
                status=grpclib.const.Status.NOT_FOUND,
            )
        rate_start_times = tariff.features.rate_start_times or ["00:00"]

        # in a real application we might iterate over database results
        # (still avoiding needing to have all the rates in-memory at once)
        for idx, dt in enumerate(PRICE_CHANGE_DATETIMES):
            for fuel_type in fuel_types:
                for region_code in region_codes:
                    yield PricePack(
                        region_code=region_code,
                        fuel_type=fuel_type,
                        existing_members_effective_at=dt,
                        new_members_effective_at=dt,
                        unit_rates=[
                            UnitRate(
                                cents=20 + idx,
                                unit=Unit.KWH,
                                start_time=rate_start_time,
                            )
                            for rate_start_time in rate_start_times
                        ],
                        standing_charge=StandingCharge(
                            cents=1000 + idx,
                            interval=Interval.DAILY,
                        ),
                    )

    async def stream_update_rates_for_price_change(
        self, request_iterator: AsyncIterator[PriceChangeTariffPricePack]
    ) -> protobuf.Empty:
        async for pctpp in request_iterator:
            # these could be upserted into a database in batches, to avoid
            # having all of them in memory at once
            print(pctpp)
        return protobuf.Empty()


async def main() -> None:
    # a single gRPC server can present multiple RPC services
    services: list[IServable] = [TariffService()]

    # ServerReflection adds a service that provides service and message
    # definitions to callers (used by tools like grpcui)
    # https://grpclib.readthedocs.io/en/latest/reflection.html
    services = ServerReflection.extend(services)

    # gRPC has a convention for health checking that can be used for k8s etc.
    # grpclib provides a helper for setting up the expected service
    # which can perform periodic checks, or can be set to SERVING/NOT_SERVING
    # https://grpclib.readthedocs.io/en/latest/health.html

    async def simple_test() -> Optional[bool]:
        return True

    services = services + [Health({OVERALL: [ServiceCheck(simple_test)]})]

    # https://grpclib.readthedocs.io/en/latest/server.html
    server = Server(services)
    # metadata.py describes how we use grpclib events to send/receive metadata
    # (and prints metadata we receive from clients)
    listen_for_metadata(server)

    with graceful_exit([server]):
        await server.start("127.0.0.1", 50051)
        print(f"Running {services}")
        await server.wait_closed()


if __name__ == "__main__":
    asyncio.run(main())
